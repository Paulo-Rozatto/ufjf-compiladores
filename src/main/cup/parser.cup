package lang;

import java_cup.runtime.*;
import de.jflex.Lexer;
import br.ufjf.estudante.ast.*;

parser code{:
    public boolean syntaxErrors;

    Lexer lexer;

    public Parser(Lexer lex) {
        super(lex);
        lexer = lex;
    }
:};

terminal String IDENTIFIER;
// Keywords
terminal IF, THEN, ELSE, PRINT, READ, ITERATE, RETURN, NEW, DATA;
// Primitives
terminal TypePrimitive INT, FLOAT, CHAR, BOOL;
terminal String CUSTOM;
// Literals
terminal int     LIT_INT;
terminal float   LIT_FLOAT;
terminal char    LIT_CHAR;
terminal boolean LIT_BOOL;
terminal LIT_NULL;
// Braces
terminal ROUND_L, ROUND_R, SQUARE_L, SQUARE_R, CURLY_L, CURLY_R;
// Separators
terminal COLON, SEMICOLON, DOUBLE_COLON, DOT, COMMA;
// Logical operators
terminal GREATER, SMALLER, EQUALS, NOT_EQUALS, AND, NOT;
// Math operators
terminal ATTRIBUTION, ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, MOD;

non terminal Program prog;
non terminal DefinitionList defList;
non terminal Definition def;
non terminal Data data;
non terminal Declaration decl;
non terminal fun;
non terminal retType;
non terminal retTypeList;
non terminal Type type;
non terminal Type btype;
non terminal cmdList;
non terminal cmd;
non terminal retIds;
non terminal ids;
non terminal exp;
non terminal lvalue;
non terminal exps;
non terminal params;
non terminal cond;

precedence left ADDITION, SUBTRACTION;
precedence left MULTIPLICATION, DIVISION, MOD;

precedence nonassoc ATTRIBUTION;
precedence nonassoc AND;
precedence left EQUALS, NOT_EQUALS, SMALLER;

precedence right NOT, NEW, COMMA, ELSE;

start with prog;

prog ::= defList:d                                                  {: RESULT = new Program(d, dleft); :};

defList ::=                                                         {: RESULT = new DefinitionList(-1); :}
    | defList:dl def:d                                              {: RESULT = dl; RESULT.add(d); :};

def ::= fun:f                                                       {: RESULT = new Data("temp", null, -1); :}
    | data:d                                                        {: RESULT = d; :};

data ::= DATA CUSTOM:name CURLY_L decl:d CURLY_R                    {: RESULT = new Data(name, d, nameleft); :};

decl ::= decl:d IDENTIFIER:i DOUBLE_COLON type:t SEMICOLON          {: RESULT = d; RESULT.add(i, t); :}
    | IDENTIFIER:i DOUBLE_COLON type:t SEMICOLON                    {: RESULT = new Declaration(ileft); RESULT.add(i, t); :};

fun ::= IDENTIFIER:id ROUND_L params:p ROUND_R retType CURLY_L cmdList CURLY_R;

retType ::=
    | COLON retTypeList;

retTypeList ::= retTypeList COMMA retTypeList
    | type ;

type ::= type:t SQUARE_L SQUARE_R {: RESULT = t; t.increaseDimensions(); :}
    | btype:b {: RESULT = b; :};


btype ::= INT:i {: RESULT = new TypePrimitive<Integer>(ileft); :}
    | FLOAT:i {: RESULT = new TypePrimitive<Float>(ileft); :}
    | CHAR:i {: RESULT = new TypePrimitive<Character>(ileft); :}
    | BOOL:i {: RESULT = new TypePrimitive<Boolean>(ileft); :}
    | CUSTOM:i {: RESULT = new TypeCustom(ileft); :};

cmdList ::= cmdList cmd | cmd;

cmd ::= CURLY_L cmdList CURLY_R
    | IF ROUND_L exp:e ROUND_R cmd
    | IF ROUND_L exp:e ROUND_R cmd ELSE cmd
    | ITERATE ROUND_L exp ROUND_R cmd
    | READ lvalue SEMICOLON
    | PRINT exp SEMICOLON
    | RETURN exps SEMICOLON
    | lvalue ATTRIBUTION exp SEMICOLON
    | IDENTIFIER ROUND_L exps ROUND_R retIds SEMICOLON;
retIds ::=
    | SMALLER ids GREATER;
ids ::= IDENTIFIER
    | ids COMMA ids;
exp ::= exp AND exp
    | exp SMALLER exp
    | exp EQUALS exp
    | exp NOT_EQUALS exp
    | exp ADDITION exp
    | exp SUBTRACTION exp
    | exp MULTIPLICATION exp
    | exp DIVISION exp
    | exp MOD exp
    | NOT exp
    | SUBTRACTION exp
    | LIT_BOOL
    | LIT_NULL
    | LIT_INT
    | LIT_FLOAT
    | LIT_CHAR
    | lvalue
    | ROUND_L exp ROUND_R
    | NEW type
    | NEW type SQUARE_L exp SQUARE_R // talvez de errado em arrays com 3+ dimensoes
    | IDENTIFIER ROUND_L exps ROUND_R SQUARE_L exp SQUARE_R;
lvalue ::= IDENTIFIER
    | lvalue SQUARE_L exp SQUARE_R
    | lvalue DOT IDENTIFIER;
exps ::=
    | exp
    | exp COMMA exp;
params ::=
    | params COMMA params
    | IDENTIFIER:i DOUBLE_COLON type:t;