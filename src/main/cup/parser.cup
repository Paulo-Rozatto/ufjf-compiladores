package lang;

import java_cup.runtime.*;
import de.jflex.Lexer;
import br.ufjf.estudante.ast.*;

parser code{:
    public boolean syntaxErrors;

    Lexer lexer;

    public Parser(Lexer lex) {
        super(lex);
        lexer = lex;
    }
:};

terminal String IDENTIFIER;
// Keywords
terminal IF, THEN, ELSE, PRINT, READ, ITERATE, RETURN, NEW, DATA;
// Primitives
terminal TypePrimitive INT, FLOAT, CHAR, BOOL;
terminal String CUSTOM;
// Literals
terminal int     LIT_INT;
terminal float   LIT_FLOAT;
terminal char    LIT_CHAR;
terminal boolean LIT_BOOL;
terminal LIT_NULL;
// Braces
terminal ROUND_L, ROUND_R, SQUARE_L, SQUARE_R, CURLY_L, CURLY_R;
// Separators
terminal COLON, SEMICOLON, DOUBLE_COLON, DOT, COMMA;
// Logical operators
terminal GREATER, SMALLER, EQUALS, NOT_EQUALS, AND, NOT;
// Math operators
terminal ATTRIBUTION, ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, MOD;

non terminal Program prog;
non terminal DefinitionsList defList;
non terminal Definition def;
non terminal Data data;
non terminal Declarations decl;
non terminal Function fun;
non terminal Params params;
non terminal ReturnTypes retTypes;
non terminal ReturnTypes retTypesList;
non terminal Type type;
non terminal Type btype;
non terminal CommandsList cmdList;
non terminal Command cmd;
non terminal retIds;
non terminal ids;
non terminal Expression exp;
non terminal LValue lvalue;
non terminal ExpressionsList exps;
non terminal cond;

precedence left ADDITION, SUBTRACTION;
precedence left MULTIPLICATION, DIVISION, MOD;

precedence nonassoc ATTRIBUTION;
precedence nonassoc AND;
precedence left EQUALS, NOT_EQUALS, SMALLER;

precedence right NOT, NEW, COMMA, ELSE;

start with prog;

prog ::= defList:d                                                              {: RESULT = new Program(d, dleft); :};

defList ::=                                                                     {: RESULT = new DefinitionsList(-1); :}
    | defList:dl def:d                                                          {: RESULT = dl; RESULT.add(d); :};

def ::= fun:f                                                                   {: RESULT = f; :}
    | data:d                                                                    {: RESULT = d; :};

data ::= DATA CUSTOM:name CURLY_L decl:d CURLY_R                                {: RESULT = new Data(name, d, nameleft); :};

decl ::= decl:d IDENTIFIER:i DOUBLE_COLON type:t SEMICOLON                      {: RESULT = d; RESULT.add(i, t); :}
    | IDENTIFIER:i DOUBLE_COLON type:t SEMICOLON                                {: RESULT = new Declarations(ileft); RESULT.add(i, t); :};

fun ::= IDENTIFIER:id ROUND_L params:p ROUND_R retTypes:r CURLY_L cmdList:c CURLY_R {: RESULT = new Function(id, p, r, c, idleft); :};

params ::=
    | params:p COMMA IDENTIFIER:i DOUBLE_COLON type:t                           {: RESULT = p; RESULT.add(i, t); :}
    | IDENTIFIER:i DOUBLE_COLON type:t                                          {: RESULT = new Params(ileft); RESULT.add(i, t); :};

retTypes ::=
    | COLON retTypesList:r {: RESULT = r; :};

retTypesList ::= retTypesList:r COMMA type:t                                    {: RESULT = r; RESULT.add(t); :}
    | type:t                                                                    {: RESULT = new ReturnTypes(tleft); RESULT.add(t); :};

type ::= type:t SQUARE_L SQUARE_R                                               {: RESULT = t; t.increaseDimensions(); :}
    | btype:b                                                                   {: RESULT = b; :};

btype ::= INT:i                                                                 {: RESULT = new TypePrimitive<Integer>(ileft); :}
    | FLOAT:i                                                                   {: RESULT = new TypePrimitive<Float>(ileft); :}
    | CHAR:i                                                                    {: RESULT = new TypePrimitive<Character>(ileft); :}
    | BOOL:i                                                                    {: RESULT = new TypePrimitive<Boolean>(ileft); :}
    | CUSTOM:i                                                                  {: RESULT = new TypeCustom(ileft); :};

cmdList ::= cmdList:cl cmd:c                                                    {: RESULT = cl; RESULT.add(c); :}
    | cmd:c                                                                     {: RESULT = new CommandsList(cleft); RESULT.add(c); :};

cmd ::= CURLY_L cmdList:c CURLY_R                                               {: RESULT = c; :}
    | IF ROUND_L exp:e ROUND_R cmd:c                                            {: RESULT = new CommandIf(e, c, eleft); :}
    | IF ROUND_L exp:e ROUND_R cmd:c1 ELSE cmd:c2                               {: RESULT = new CommandIf(e, c1, c2, eleft); :}
    | ITERATE ROUND_L exp:e ROUND_R cmd:c                                       {: RESULT = new CommandIterate(e, c, eleft); :}
    | READ lvalue:l SEMICOLON                                                   {: RESULT = new CommandRead(l, lleft); :}
    | PRINT exp:e SEMICOLON                                                     {: RESULT = new CommandPrint(e, eleft); :}
    | RETURN exps:e SEMICOLON                                                   {: RESULT = new CommandReturn(e, eleft); :}
    | lvalue:l ATTRIBUTION exp:e SEMICOLON                                      {: RESULT = new CommandAttribution(l, e, lleft); :}
    | IDENTIFIER ROUND_L exps:e ROUND_R retIds:r SEMICOLON                      {: RESULT = new CommandCall(e, r, eleft); :};

lvalue ::= IDENTIFIER // todo: missing returning actually LValue here
    | lvalue SQUARE_L exp SQUARE_R
    | lvalue DOT IDENTIFIER;

retIds ::= // todo: missing class and returing write value here
    | SMALLER ids GREATER;

ids ::= IDENTIFIER
    | ids COMMA IDENTIFIER;

exp ::= exp AND exp
    | exp SMALLER exp
    | exp EQUALS exp
    | exp NOT_EQUALS exp
    | exp ADDITION exp
    | exp SUBTRACTION exp
    | exp MULTIPLICATION exp
    | exp DIVISION exp
    | exp MOD exp
    | NOT exp
    | SUBTRACTION exp
    | LIT_BOOL
    | LIT_NULL
    | LIT_INT
    | LIT_FLOAT
    | LIT_CHAR
    | lvalue
    | ROUND_L exp ROUND_R
    | NEW type
    | NEW type SQUARE_L exp SQUARE_R // talvez de errado em arrays com 3+ dimensoes
    | IDENTIFIER ROUND_L exps ROUND_R SQUARE_L exp SQUARE_R;

exps ::= {: RESULT = new ExpressionsList(0); :}
    | exp:e {: RESULT = new ExpressionsList(eleft); RESULT.add(e); :}
    | exps:es COMMA exp:e {:  RESULT = es; RESULT.add(e); :};